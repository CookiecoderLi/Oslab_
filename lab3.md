# 练习1：理解基于FIFO的页面替换算法



#### 理解代码的执行流

**主执行流：** init--->swap_init--->check_swap--->check_content_access--->sm->check_swap()--->发生缺页异常--->trap()--->exception_handler--->pgfault_handler--->do_pgfault--->swap_in、page_insert、swap_map_swappable

**swap_in分支**：swap_in->alloc_page--->alloc_pages--->swap_out--->sm->swap_out_victim

**page_insert分支**：page_insert--->tlb_validate



#### 1、swap_init函数

用于初始化页面交换系统。具体来说，该函数首先调用`swapfs_init`函数初始化磁盘交换分区。然后，它检查最大交换偏移量是否在某个范围内，如果不在范围内，则输出错误信息并引发紧急情况。接着，该函数选择使用时钟页面置换算法，并调用该算法的`init`函数进行初始化。如果初始化成功，则将`swap_init_ok`标记为真，并输出当前使用的页面置换算法的名称。最后，该函数调用`check_swap`函数来检查页面置换算法的正确性和可靠性。

其中涉及`swapfs_init`、`sm->init`等函数

1. `swapfs_init`函数：使用`static_assert`宏检查页面大小是否是扇区大小的整数倍，如果不是，则会在编译时引发错误。接着，该函数调用`ide_device_valid`函数检查磁盘交换分区是否可用，如果不可用，则输出错误信息并引发紧急情况。最后，该函数计算最大交换偏移量，即磁盘交换分区的大小除以页面大小，以便在后续的页面置换算法中使用
2. `sm->init`函数：调用所选内存置换算法的init函数，现在选择的是上面提及的** _fifo_init_mm(struct mm_struct *mm)**

#### 2、check_swap函数

检查页面交换函数。该函数首先备份内存环境，然后设置物理页面环境，并创建一个虚拟内存区域。接着，它分配4个物理页面，并重新初始化空闲页面链表。然后，它设置初始的虚拟页面和物理页面的映射关系，并调用不同页面置换算法的`check`函数来检查算法

其中涉及到`vma_create`，`insert_vma_struct`函数

1. `vma_create`函数：vma的创建并初始化，根据参数`vm_start`、`vm_end`、`vm_flags`完成初始化
2. `insert_vma_struct`函数：向mm的mmap_list的插入一个vma，按地址插入合适位置
3. `check_content_set`函数：初步检查页面交换函数，进行一些基本的访存和缺页处理
   
   

#### 3、check_content_access函数

调用不同页面置换算法的check函数检查算法。当发生缺页异常的时候进入trap.c中的trap函数转到处理异常的函数`exception_handler`，随后进入`pgfault_handler`函数进行缺页的正常处理，并使用变量`ret`承接`pgfault_handler`函数的返回值，返回值为0表明处理成功，否则就使用`print_trapframe`函数打印寄存器状态，并输出一个错误消息。

在`pgfault_handler`函数中首先调用`print_pgfault`打印异常发生的地址等信息，随后使用`do_pgfault`函数处理缺页异常。

#### 4、do_pgfault函数

接受一个指向`mm_struct`结构体的指针、一个错误码和一个地址作为参数。该函数首先使用函数`find_vma`尝试查找包含该地址的`vma`结构体，如果找不到或者该地址不在任何`vma`的范围内，则输出错误信息并返回无效值。接着，它检查该地址是否可写，并根据需要设置相应的页权限。然后，它将该地址向下对齐到页面大小的整数倍，找到发生缺页的地址所在的页面的首地址。接下来，它使用`get_pte`函数尝试获取该页面的页表条目，如果该条目为空，则使用`pgdir_alloc_page`函数尝试为该页面分配一个新页面并设置适当的权限。如果该条目不为空，则说明该页面已经被映射到物理页面上，此时需要根据该页表条目的交换条目信息，使用`swap_in`函数从磁盘中加载数据，再使用`page_insert`函数将其映射到物理页面上，然后使用`swap_map_swappable`函数设置页面为可交换的。最后，该函数返回0表示成功，或者返回错误码表示失败。

1. `find_vma`函数：用于查找包含给定地址的虚拟内存区域（VMA）。函数接受一个指向`mm_struct`结构体的指针和一个地址作为参数。它首先检查`mm`指针是否为空，如果为空则返回空指针。接着，它尝试从`mm`结构体中的`mmap_cache`字段中查找包含该地址的VMA，如果找到则直接返回该VMA。如果没有找到，则遍历`mm`结构体中的`mmap_list`链表，查找包含该地址的VMA。如果找到，则返回该VMA，否则返回空指针。最后，如果找到了VMA，则将其存储在`mmap_cache`字段中以备下次查找使用。该函数的目的是在给定的进程地址空间中查找包含给定地址的虚拟内存区域。
2. `insert_vma_struct`函数：用于将一个虚拟内存区域（VMA）插入到进程的地址空间中。函数接受一个指向`mm_struct`结构体的指针和一个指向`vma_struct`结构体的指针作为参数。该函数首先检查`vma`的起始地址是否小于结束地址，如果不是，则输出错误信息并终止程序。接着，它遍历`mm`结构体中的`mmap_list`链表，找到第一个起始地址大于`vma`的起始地址的VMA，并将`vma`插入到该VMA之前。如果找不到这样的VMA，则将`vma`插入到链表末尾。在插入之前，该函数还会检查`vma`与前后VMA是否重叠，如果重叠则输出错误信息并终止程序。最后，该函数将`vma`的`vm_mm`字段设置为`mm`，并将`mm`的`map_count`字段加1。该函数的目的是将一个VMA插入到进程的地址空间中，并保证VMA按地址顺序排列，不重叠。
3. `mm_destroy`函数：用于释放一个`mm_struct`结构体及其内部字段占用的空间。该函数接受一个指向`mm_struct`结构体的指针作为参数。该函数首先遍历`mm`结构体中的`mmap_list`链表，逐个删除其中的VMA，并释放其占用的空间。然后，它释放`mm`结构体本身占用的空间，并将`mm`指针设置为`NULL`。该函数的目的是在进程退出或被销毁时，释放其占用的内存空间，避免内存泄漏。
4. `get_pte`函数：用于获取给定线性地址对应的页表项指针，并在需要时为页表分配一个新页面。该函数接受一个指向页目录表（PDT）的指针、一个线性地址和一个逻辑值作为参数。如果该页表项不存在且`create`参数为真，则该函数会为页表分配一个新页面，并将该页表项设置为新页面的物理地址。如果分配失败，则返回空指针。如果该页表项已经存在，则直接返回该页表项指针。该函数的目的是获取给定线性地址对应的页表项指针，并在需要时为页表分配一个新页面。
5. `page_insert`函数：用于将一个物理页面映射到给定的线性地址上。该函数接受一个指向页目录表（PDT）的指针、一个指向`Page`结构体的指针、一个线性地址和一个权限参数作为参数。该函数首先调用`get_pte`函数获取给定线性地址对应的页表项指针，如果该页表项不存在，则返回错误码。接着，该函数增加该物理页面的引用计数，并检查该页表项是否已经被映射到其他物理页面上。如果是，则需要先将该页表项从原物理页面中删除。然后，该函数将该页表项设置为指向给定物理页面的物理地址，并设置相应的权限。最后，该函数调用`tlb_invalidate`函数使TLB失效，以确保新的映射关系能够生效。该函数的目的是将一个物理页面映射到给定的线性地址上，并更新页表项和TLB。
6. `swap_map_swappable`函数：用于将传入函数的页面标记为可交换的，接受三个参数——指向`mm_struct`结构体的指针、前页面在进程地址空间中的虚拟地址`addr`、指向 `struct Page` 结构体的指针、整数`swap_in`标识（表示当前页面是否需要从交换空间中调入内存，如果需要则为 1，否则为 0）这里将会调用**上面提到的sm->map_swappable**

#### 5、swap_in函数

`swap_in`函数：用于将一个页面从磁盘交换区读入到物理内存中。该函数接受一个指向`mm_struct`结构体的指针、一个线性地址和一个指向`Page`结构体指针的指针作为参数。该函数首先调用`alloc_page`函数分配一个新的物理页面，并将其存储在`result`指针中。接着，它调用`get_pte`函数获取给定线性地址对应的页表项指针，并将该页表项中的交换条目读入到`result`指向的物理页面中。如果读取失败，则输出错误信息并终止程序。最后，该函数将`result`指针存储在`ptr_result`指向的指针中，并返回0表示成功。

1. `alloc_page`宏拓展到`alloc_pages(1)`,用于分配指定数量的物理页面。该函数接受一个整数参数`n`，表示需要分配的页面数量。该函数首先定义一个指向`Page`结构体的指针`page`，并将其初始化为`NULL`。然后，该函数进入一个无限循环，每次循环中，它调用`pmm_manager`指向的物理内存管理器的`alloc_pages`函数来分配页面。如果分配成功，则直接返回该页面的指针。如果分配失败，则需要检查是否可以进行页面交换。如果`swap_init_ok`为真，且需要分配的页面数量为1，则调用`swap_out`函数将一个页面交换到磁盘上，并再次尝试分配页面。如果分配成功，则返回该页面的指针。如果分配失败，则继续循环。最后，该函数返回分配的页面的指针。而在`swap_out`函数中包含`swapfs_write`、`tlb_invalidate`等函数：
   * `swap_out`函数：用于将一个页面交换到磁盘上。该函数接受一个指向`mm_struct`结构体的指针、一个整数参数`n`和一个逻辑值`in_tick`作为参数。该函数首先进入一个循环，每次循环中，它调用**上面提到的sm->swap_out_victim**函数来选择一个页面作为交换页面。如果选择失败，则输出错误信息并终止程序。接着，该函数获取该页面对应的页表项指针，并将该页表项中的交换条目写入到磁盘交换区中。如果写入失败，则需要将该页面重新标记为可交换，并继续循环。如果写入成功，则将该页面的页表项设置为交换条目的值，并释放该页面占用的物理页面。最后，该调用`tlb_invalidate`函数使TLB失效，并返回成功交换的页面数量。
   * `swapfs_write`函数：接受一个交换条目号和一个指向`Page`结构体的指针作为参数，它使用`ide_write_secs`函数将`page`指向的物理页面中的数据写入到磁盘交换分区中对应的位置。该函数返回写入的扇区数，如果写入失败，则返回错误码。这两个函数的目的是在页面置换时，将物理页面与磁盘交换分区中的数据进行读写操作。
   * `tlb_invalidate`函数：内部执行一次`flush_tlb`函数，该函数内部执行代码`asm volatile("sfence.vma");`其中`sfence.vma`是RISC-V指令集中的一个特殊指令，用于刷新TLB缓存。
2. `swapfs_read`函数：接受一个交换条目号和一个指向`Page`结构体的指针作为参数，它使用`ide_read_secs`函数从磁盘交换分区中读取对应的页面数据，并将其存储到`page`指向的物理页面中。该函数返回读取的扇区数，如果读取失败，则返回错误码。
3. `tlb_invalidate`函数：内部执行一次`flush_tlb`函数，该函数内部执行代码`asm volatile("sfence.vma");`其中`sfence.vma`是RISC-V指令集中的一个特殊指令，用于刷新TLB缓存。
   
   

# 练习2：深入理解不同分页模式下的工作原理

`get_pte()`函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

* `get_pte()`函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
* 目前`get_pte()`函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

##### 第一问：

RISC-V的分页机制为多级页表，sv32、sv39和sv48三种分页模式分别是为了适配32位、39位和48位虚拟地址空间。每一种模式都有不同数量的页表层级。

* **sv32**：对于32位虚拟地址，使用两级页表：页目录（L1）和页表（L2）。
* **sv39**：对于39位虚拟地址，使用三级页表：页目录层级1（L1）、页目录层级2（L2）和页表（L3）。
* **sv48**：对于48位虚拟地址，使用四级页表：页目录层级1（L1）、页目录层级2（L2）、页目录层级3（L3）和页表（L4）。

在本实验中使用sv39分页机制，所以在`get_pte()`函数中，有两个层级的页目录项的处理。两段代码结构非常相似是因为其涉及**处理两级页表项的操作**

所以在这三种模式中，虽然页表层级的数量不同，但每一级的行为非常相似，只是它们对应于虚拟地址的不同部分。在每一级，以下步骤都会被执行：

1. 从虚拟地址中提取相应的索引。
2. 使用这个索引在当前层级的页表/页目录中查找。
3. 如果条目不存在（即没有映射），根据需要创建一个新的页表/页目录。
4. 如果已经存在条目，转到下一层级并重复这些步骤。

当扩展到sv32或sv48时，这种模式会持续。例如，在sv48中，应该有三段非常相似的代码，每段都对应于不同的页表层级。

##### 第二问：有好有坏

将页表项的查找和分配合并在`get_pte()`函数中确实可以提供方便，因为它允许调用函数的代码更加简洁。但是，将这两个功能合并可能会对代码的可读性、模块化和重用性产生一些负面影响。以下是这种合并写法的优点和缺点：

**优点**：

1. **函数参数限制**：在`get_pte()`函数中， `create`参数决定是否为页表分配一个页，可以做到调用该函数的时候实现只查找不分配和查找分配都进行的操作，使得整个函数的功能是完整的。
2. **简化调用**：调用者不需要分别调用查找和分配函数，只需调用一个函数即可。
3. **减少错误**：由于查找和分配逻辑被封装在同一个函数中，调用者不太可能忘记执行其中的任何一步。

**缺点**：

1. **需要额外的资源（可能是硬件资源）**：由于执行`get_pte()`函数时需要针对不同的应用场景传入`create`参数，即对于查找和分配同时做的操作【比如虚拟内存分配、虚拟内存分配等】需要标识create为1，对于查找和分配操作只做一个的操作【比如只读页表项查找、修改已有页表项、回收物理内存等操作】需要标识create为0，这个标示一定需要额外的资源，在可以通过**软件工程规范**函数功能分配的场景下，分开实现以规避冗余硬件资源是更合理的选择
2. **函数的单一职责原则**：通常，每个函数应该只有一个原因进行修改，这就是所谓的函数的单一职责原则。合并两个功能可能违反了这一原则。
3. **重用性**：如果在其他地方只需要其中的一个功能（例如，只查找不分配），则该函数可能不太适用。
4. **可读性和维护性**：合并两个功能可能使函数变得更长和更复杂，这可能会降低代码的可读性和维护性。
5. **不够直观**：当某人查看`get_pte()`函数时，他们可能不会立即意识到这个函数同时负责查找和分配。

在某些情况下，为了简化代码和减少错误，合并可能是合理的。但在其他情况下，为了提高代码的模块化、可读性和重用性，将它们分开可能是更好的选择。



# 练习3：给未被映射的地址映射上物理页

#### 问题1：请描述页目录项（PageDirectoryEntry）和页表项（PageTableEntry）中组成部分对ucore实现页替换算法的潜在用处。

+ 在分页机制中，通过在一二级页表中查找虚拟地址是否存在，从而判断该地址虚拟地址是否合法。并且还可以通过修改页表中映射关系从而实现页替换算法或者通过虚拟地址查找出相对应的物理地址。

+ 页表项储存了一系列关于物理页的信息。例如该物理页是否存在，是否可读，对应的物理页是否可以被访问。

+ 页表项中还储存了页的一些信息，像该页是否被访问过、该页是否被修改，这些信息可以帮助我们实现clock替换算法。
  
  #### 问题2：如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？

+ 当出现页异常时，CPU首先会把产生的异常相关信息储存在寄存器中，并把也访问异常类型的值保存在中断栈中。

+ 之后将执行流程转交给中断处理函数，一步步执行trap->trap_dispatch->pgfault_handler->do_pafault。
  
  #### 问题3：数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

+ Page数组中每一项表示一个页面，其中的vaddr属性表示每个页面的虚拟地址，可以通过虚拟地址在每个页目录表中查找下一级的页目录表，直到最终查找到对于的页表项。
  
  # 练习4：补充完成 Clock 页替换算法
  
  #### 1.算法逻辑
  
  时钟替换算法把各个页面组织成环形的链表形式，然后把指针指向最先进来的页面，通过查找页表项中设置的访问位来判断当前的页面是否被访问过，每次也被访问时，CPU中的MMU会把访问位置为1，当操作系统需要换出页时，对当前指针所指向的页的页表项中的访问位进行查询，当为0时移出该页，如果该页被写过，则还要换到磁盘上，当为1时将访问位置为0，继续访问下一个页面。
  注：在此时钟替换算法中，淘汰一个页面只考虑页面是否被访问过，并未考虑该页是否被修改过，实际中有所考虑。
  
  #### 2.具体实现

+ 页面替换算法的初始化
  将替换算法中需要的pra_list_head链表进行初始化，并将当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头。将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作。
  
  ```
  static int _clock_init_mm(struct mm_struct *mm){
    list_init(&pra_list_head);
    curr_ptr = &pra_list_head;
    mm->sm_priv = &pra_list_head;
    cprintf(" mm->sm_priv %x in fifo_init_mm\n", mm->sm_priv);
    return 0;
  }
  ```

+ 向链表最后插入新来的页
  将页面插入到页面链表pra_list_head的末尾并将页面的visited标志置为1，表示该页面已被访问。
  
  ```
  static int _ clock_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in)
  {
    list_entry_t *entry = &(page->pra_page_link);
    assert(entry != NULL && curr_ptr != NULL);
    list_entry_t *head = (list_entry_t *)mm->sm_priv;
    list_add(head, entry);
    page->visited = 1;
    curr_ptr = entry;
    cprintf("curr_ptr %p\n", curr_ptr);
    return 0;
  }
  ```

+ 移除页面
   遍历页面链表pra_list_head，查找最早未被访问的页面,如果当前页面未被访问，则将该页面从页面链表中删除，并将该页面指针赋值给ptr_page作为换出页面, 如果当前页面已被访问，则将visited标志置为0，表示该页面已被重新访问。
  
  ```
  static int _clock_swap_out_victim(struct mm_struct *mm, struct Page **ptr_page, int in_tick)
  {
    list_entry_t *head = (list_entry_t *)mm->sm_priv;
    assert(head != NULL);
    assert(in_tick == 0);
    list_entry_t *tmp = head;
    while (1)
    {
        list_entry_t *entry = list_prev(tmp);
        struct Page *p = le2page(entry, pra_page_link);
        if (p->visited == 0)
        {
            list_del(entry);
            *ptr_page = p;
            cprintf("curr_ptr %p\n", curr_ptr);
            break;
        }
        if (p->visited == 1)
        {
            p->visited = 0;
        }
  
        tmp = entry;
    }
    return 0;
  }
  ```
  
  #### 3.比较Clock页替换算法和FIFO算法的不同

+ FIFO页替换算法： 根据页面进入内存的先后顺序进行替换，即最早进入内存的页面先被替换。使用队列数据结构来维护页面的进入顺序。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高，且存在Belady现象，即在增加放置页的物理页帧的情况下，反而使页访问异常次数增多。

+ clock页替换算法：时钟页替换算法把各个页面组织成环形链表的形式，每个页面都有一个引用位，当页面被访问时，引用位被设置为1，当需要替换页面时，从当前位置开始查找引用位为0的页面进行替换。该算法易于实现，开销少，但需要硬件支持来设置访问位。时钟页替换算法在本质上与FIFO算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为1的页，且没有Belady现象。
  
  

# 练习5：采用一个大页的各方面理解

#### 一个大页的优势：

1. **减少页表大小**：一个大页意味着更少的页表项，这可以减小页表的大小，从而减少内存占用和页表维护的开销。

2. **提高TLB（Translation Lookaside Buffer）效率**：TLB是存储最近访问的页表项的高速缓存，一个大页可以容纳更多的物理地址范围，减少了TLB的命中率，提高了内存访问速度。

3. **减少缺页中断次数**：由于更多数据可以在一个大页中，这减少了需要从磁盘加载数据的次数，减少了缺页中断的频率，从而提高了性能。 

#### 劣势：

1. **内部碎片**：如果一个大页没有被充分利用，它可能会导致内存中的内部碎片，因为操作系统需要为整个大页分配内存，即使只使用了其中的一部分。

2. **不适用于所有应用**：某些应用程序可能不适合大页，因为它们的内存访问模式无法受益于大页的优势。
